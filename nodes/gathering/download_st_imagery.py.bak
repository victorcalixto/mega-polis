import bpy
from bpy.props import IntProperty, BoolProperty

from sverchok.node_tree import SverchCustomTreeNode
from sverchok.data_structure import updateNode

#Megapolis Dependencies

from megapolis.dependencies import mapillary as mly
from megapolis.dependencies import requests

try:
    from pyproj import Transformer
except:
    pass

import os
import threading


class SvMegapolisDownloadStImagery(SverchCustomTreeNode, bpy.types.Node):
    """
    Triggers: Download Street Imagery
    Tooltip: Download Geo-Referenced Mapillary Street Imagery
    """
    bl_idname = 'SvMegapolisDownloadStImagery'
    bl_label = 'Download Street Imagery'
    bl_icon = 'IMAGE_RGB'
    sv_dependencies = {'mapillary', 'requests'}

    # Hide Interactive Sockets
    def update_sockets(self, context):
        """ need to do UX transformation before updating node"""
        def set_hide(sock, status):
            if sock.hide_safe != status:
                sock.hide_safe = status
        
        updateNode(self,context)

    #Blender Properties Buttons

    projection: IntProperty(
        name="projection",
        description="CSR Projection Number",
        default=4236,
        update=update_sockets)
    
    download: BoolProperty(
        name='download', 
        default=False,
        description='Download the Street Imagery', 
        update=update_sockets)

    def sv_init(self, context):
        # inputs
        self.inputs.new('SvStringsSocket', "Mapillary_Key")
        self.inputs.new('SvStringsSocket', "Folder")
        #self.inputs.new('SvStringsSocket', "Radius")
        self.inputs.new('SvStringsSocket', "Longitude")
        self.inputs.new('SvStringsSocket', "Latitude")
        self.inputs.new('SvStringsSocket', "Max_Num_Photos")

        # outputs
        
        self.outputs.new('SvStringsSocket', "Images_Index")
        self.outputs.new('SvVerticesSocket', "Coordinates")
        self.outputs.new('SvStringsSocket', "Output_Message")
                    
    def draw_buttons(self,context, layout):
        layout.prop(self, 'download')
        layout.prop(self, 'projection')

    def draw_buttons_ext(self, context, layout):
        self.draw_buttons(context, layout)

    def process(self):
         
        if self.download == False or not self.inputs["Folder"].is_linked:
            return
        self.mapillary_key = self.inputs["Mapillary_Key"].sv_get(deepcopy = False) 
        self.folder = self.inputs["Folder"].sv_get(deepcopy = False)
        self.longitude = self.inputs["Longitude"].sv_get(deepcopy = False)
        self.latitude = self.inputs["Latitude"].sv_get(deepcopy = False)
        self.max_photos = self.inputs["Max_Num_Photos"].sv_get(deepcopy = False)

        mapillary_key = str(self.mapillary_key[0][0])
        folder_name = str(self.folder[0][0])
        longitude =float(self.longitude[0][0])
        latitude = float(self.latitude[0][0])
        max_photos = self.max_photos[0][0]

        location = []
        mly.interface.set_access_token(mapillary_key)
        print(f"longitude: {longitude}")
        print(f"latitude:{latitude}")
        images_dict = mly.interface.get_image_close_to(longitude,latitude)
        data = images_dict.to_dict()
        print(data)
        images_id = mly.utils.extract.extract_properties(data,properties=['id'])
        message = []

        def downloadImages(images,folder_name,location,message):
            try:
                os.mkdir(folder_name)
            except:
                pass
            for i in images:
                header = {'Authorization' : 'OAuth {}'.format(mapillary_key)}
                url_json=f"https://graph.mapillary.com/{i}?access_token={mapillary_key}&fields=thumb_original_url,computed_geometry,captured_at,computed_compass_angle"    
                
                response = requests.get(url_json,headers=header)
                data = response.json()
                image_url = data['thumb_original_url']
                
                if response.status_code == 200:
                    with open(f"{folder_name}/{i}.jpg", 'wb') as f:
                        image_data = requests.get(image_url, stream=True).content
                        f.write(image_data)
                print(f"Downloaded {i}.jpg in {folder_name}")
                location.append(data["computed_geometry"]["coordinates"])
                print(location)
                message.append(f"Downloaded {i}.jpg in {folder_name}")

        images = images_id['id']

        slice = images[0:int(max_photos)]

        if self.download == True:
            t1 = threading.Thread(target=downloadImages, args=(slice,folder_name,location,message))
            t1.start()
            t1.join()

        coords = []

        transformer = Transformer.from_crs("+proj=latlon",f"epsg:{self.projection}")

        for i in location:
           x = i[0]
           y = i[1]
           x,y = transformer.transform(x,y)
           z = 0
           coords.append([x,y,z])

        coords = [coords]

        ## Outputs
        
        self.outputs["Images_Index"].sv_set(images)
        self.outputs["Coordinates"].sv_set(coords)
        self.outputs["Output_Message"].sv_set(message)

def register():
    bpy.utils.register_class(SvMegapolisDownloadStImagery)


def unregister():
    bpy.utils.unregister_class(SvMegapolisDownloadStImagery)
